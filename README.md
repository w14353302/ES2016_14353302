# ES2016_14353302
***
#一. 实验过程   
1. 按照ppt给出的代码生成Deadlock.java文件   
![1.png](https://ooo.0o0.ooo/2016/10/25/580f8bbd90a76.png)   
2. 在windows系统下运行javac Deadlock.java文件，生成.class文件   
3. 在windows系统下生成.bat文件，并将该文件放在.class的目录下   
![2.png](https://ooo.0o0.ooo/2016/10/25/580f8bf36df71.png)   
4. 双击.bat文件，观察结果：发现在第291次的时候发生死锁   
![3.png](https://ooo.0o0.ooo/2016/10/25/580f8c3c8ad46.png)   
#二. 产生死锁的四个必要条件   
* 如果在一个系统中下面四个条件同时满足，那么会引起死锁   
1. 互斥：至少有一个资源必须处于非共享模式，即一次只有一个进程使用。如果另一进程申请该资源，那么申请进程必须等到该资源被释放为止   
2. 占有并等待：一个进程必须占有至少一个资源，并等待另一资源，而该进程为其他进程所占有   
3. 非抢占：资源不能被抢占，即资源只能在进程完成任务后自动释放   
4. 循环等待：有一组等待进程{p0,p1,...pn},p0等待的资源为p1占有，p1等待的资源为p2占有,...，Pn-1等待的资源为pn所占有，pn等待的资源为p0所占有。   
#三. 对上述程序产生死锁的解释   
![4.png](https://ooo.0o0.ooo/2016/10/25/580f8ce425853.png)   
* 产生死锁的原因是上图?左右两边发生的时间是否在同一时间，a请求b，b请求a若在同一时间则会发生死锁。即a.methodA(b)里的b.last() 和 b.methodB(a)里的a.last()执行的时间比较接近，彼此都在请求对方资源，而且同时发生的时候 就会有死锁了。   
* synchronized限定当一个类的一个资源被某一个线程占用，其他的资源就不可以被另外的线程申请到，在这种情况下，两个线程分别占有一个资源又申请对方所占用的资源，但是对方本身占用资源又必须等到申请到资源之后才可以释放，就会产生死锁。   
#四. 实验感想   
这次实验了解了死锁发生的四个必要条件，之前操作系统也有学过，所以是很容易懂的。因为自己的电脑配置了java环境，所以直接在windows系统中运行,bat文件挺简单的，


